#= Last updated: 2/20/2025

This code is based on code generated by J Ben Falandays
and then worked by Kyra Veprek.

This runs a comparison between the simulated agent data 
and the data from Kyra's first collision avoidance experiment in which a
participant walked through a crowd of 10 avatars. 

There are 2 IVS:
-density: Low, High
-speed: 1, 2, 3

Note as of 2/20: I did not rotate the data in Matlab because I think there's something wrong with the rotation so 
the position information comes from '.P' instead of ".pFinal" and the goal position changes each trial
 =#

using Distributed
# Load data
global gridSearchNum = "1"

using VENlab_UniversalSim
using MAT

file = matopen("./ExperimentSimulations/LocalComputing/diss_exp1/dataSorted_dissExp1_Rotated.mat")
data = read(file, "dataSorted")

@changeVal min_x = 100;
global min_x = 100;
@changeVal min_y = 100;
global min_y = 100;

#Initialize the models dataframe
models = []

# Check to make sure you are looking at the trials that you want to.
# For exaple set data["info"][cur_subj, cur_trial]["numObj"] != 0 if you want to skip
# free walk trials. 

#= cur_subj = 4;
cur_trial = 26; =#
for kH in 10.0:10.0:50.0 
    for cH1 in 1.0:15.0:91.0 
        for cH2 in 1.0:15.0:91.0 
            for cur_subj in 1:12 #6
                for cur_trial in 1:106 #100
                    if data["info"][cur_subj, cur_trial]["Density"] != 0
                        push!(models,
                            Dict(
                                :subject => cur_subj,
                                :trial => cur_trial,
                                :dt => 1/90, # IMPORTANT! MAKE SURE YOU ADJUST SAMPLING RATE
                                :modelType => "visual",
                                :alignment => false,
                                :visAlignmentFunc => 0,
                                :peopleAsObstacles => true,
                                :headingExpansionThreshold => true,
                                :hEthreshVal => 2.2, #degres/second
                                :speedControlGoals => true,
                                :speedControlObstacles => true,
                                :obstacleModel3_constants => Dict(
                                    # heading control params for obstacle model 3
                                    :kᵩ => Float32(kH), 
                                    :c₁ᵩ => Float32(cH1),
                                    :c₂ᵩ => Float32(cH2),

                                    :kₛ => Float32(24.14), 
                                    :c₁ₛ => Float32(9.43),
                                    :c₂ₛ => Float32(27.94)
                                )
                            )
                        )
                    end
                end
            end
        end
    end
end

function myCustomRails(agent::Agent, model::AgentBasedModel)

    # First, increment the time for the agent, in both "real time" (simulated seconds) and "step time" (number of model steps)
    agent.realTime += model.dt
    agent.stepTime += 1

    #first record the current complexPos
    old_pos = agent.complexPos
    
    x_id = 'A' * string(agent.id) * "_xpos"
    y_id = 'A' * string(agent.id) * "_ypos"
    
    # Get the next position data -- the data corresponding to the time step we've just updated to.
    newX = leader_data[agent.stepTime, x_id] #+ abs(xmin)
    newY = leader_data[agent.stepTime, y_id] #+ abs(ymin)
    # Notice that we are adding "abs(xmin)" and "abs(ymin)" to every position, which will ensure that position is never < 0

    # I'll also point out that all agents have an "inputData" field that you could use to store the data INSIDE the agent, if you wish.
    # That is sometimes useful when you're on the cluster, to avoid having to deal with passing data across cores.

    #= move the agent, using the "move_agent!()" function from Agents.jl, which requires (1) the agent, (2) the position to move to, (3) the model.
    You don't actually have to use this function, but I wanted to show it because it conveniently takes care of periodic boundary conditions,
    should you ever need them in the future (though we have hard boundaries in this model).
    =#
    move_agent!(agent, (newX, newY), model)

    # update the agent.complexPos property, because this is not updated automatically by move_agent!.
    # Complex coordinates are of the form "x + y*im" ("im" means "imaginary", aka the imaginary unit i; 
    # Julia still understands if you leave out the "*").
    agent.complexPos = (agent.pos[1] + agent.pos[2]im)

    #update the heading and speed, calculated directly from the change in position
    agent.heading = angle(agent.complexPos - old_pos)
    agent.speed = abs(agent.complexPos-old_pos)/model.dt

    return nothing # we are updating everything inside the agent, so we don't need to return anything

end



function runmodel(n)
    local modelinfo = models[n]

    props = deepcopy(getProperties())
    merge!(props, modelinfo)
    
    model = ABM(Agent, ContinuousSpace((300, 300), periodic=false);
        properties=props, scheduler=Schedulers.fastest)

    model.customRailsFunc = myCustomRails

    local nSteps = size(data["P"][model.subject, model.trial])[1] - 1

    global critTime = 1
    global Density = Int(data["info"][model.subject, model.trial]["Density"])
    global O_Speed = data["info"][model.subject, model.trial]["Speed"]

    ## add the participant agent
    initHeading = getHeading_rad(data["P"][model.subject, model.trial][:, 1], data["P"][model.subject, model.trial][:, 2])[1]

    add_agent_pos!(
        Person(
            id=nextid(model),
            pos=(
                data["P"][model.subject, model.trial][2, 1] + min_x,
                data["P"][model.subject, model.trial][2, 2] + min_y
            ),
            speed=data["spd"][model.subject, model.trial][3], # or rand(Uniform(.1,2))
            heading=initHeading,
        ),
        model
    )
    model[1].supertype = :person


    ### Notes on below: The goal model is making use of preferredSpeed, so we need to set it appropriately. The approach we went with was to get the mean speed during the middle third of the trial.
    third = Int(round(length(data["spd"][model.subject, model.trial]) / 3))
    #model[1].preferredSpeed = mean(data["spd"][model.subject,model.trial]) #
    model[1].preferredSpeed = mean(data["spd"][model.subject, model.trial][third:(third*2)])

    # And we'll add our leader agent, who is a :personOnRails type
    for avatar in 1:10
        #i think this is just necessary for the start positioning, see end of script, loop over only to place the agents
        id = 'A' * string(avatar) * 'P'

        pos_x = data[id][model.subject, model.trial][:, 1] 
        pos_y = data[id][model.subject, model.trial][:, 2] 
        heading_speed = getHeadingSpeed(pos_x, pos_y)
        heading_speed[2] ./= model.dt

        add_agent_pos!(
            PersonOnRails(
                id = nextid(model),
                pos = (pos_x[1]+ min_x, pos_y[1]+ min_y),
                heading = heading_speed[1][1],
                speed = heading_speed[2][1],
                goal_group = 2
            ),
            model
        )

    end


    add_agent_pos!(
        goal_static(
            id=nextid(model),
            pos=(0 + min_x, sqrt(9^2 + 11^2) + min_y)
        ),
        model
    )

    step!(model, dummystep, model_step!, nSteps)

    #Recording the position of simulated agent
    subj_df = filter(:id => id -> id == 1, model.df)
    subj_df[!, "subj"] = repeat([model.subject], nrow(subj_df))
    subj_df[!, "trial"] = repeat([model.trial], nrow(subj_df))
    subj_df[!, "xpos"] = [x[1] - min_x for x in subj_df[:, "pos"]]
    subj_df[!, "ypos"] = [y[2] - min_y for y in subj_df[:, "pos"]]
    subj_df = subj_df[:, 4:end]

    av1_df = filter(:id => id -> id == 2, model.df)
    av1_df[!, "xpos"] = [x[1] - min_x for x in av1_df[:, "pos"]]
    av1_df[!, "ypos"] = [x[2] - min_y for x in av1_df[:, "pos"]]

    av2_df = filter(:id => id -> id == 3, model.df)
    av2_df[!, "xpos"] = [x[1] - min_x for x in av2_df[:, "pos"]]
    av2_df[!, "ypos"] = [x[2] - min_y for x in av2_df[:, "pos"]]

    av3_df = filter(:id => id -> id == 4, model.df)
    av3_df[!, "xpos"] = [x[1] - min_x for x in av3_df[:, "pos"]]
    av3_df[!, "ypos"] = [x[2] - min_y for x in av3_df[:, "pos"]]

    av4_df = filter(:id => id -> id == 5, model.df)
    av4_df[!, "xpos"] = [x[1] - min_x for x in av4_df[:, "pos"]]
    av4_df[!, "ypos"] = [x[2] - min_y for x in av4_df[:, "pos"]]

    av5_df = filter(:id => id -> id == 6, model.df)
    av5_df[!, "xpos"] = [x[1] - min_x for x in av5_df[:, "pos"]]
    av5_df[!, "ypos"] = [x[2] - min_y for x in av5_df[:, "pos"]]

    av6_df = filter(:id => id -> id == 7, model.df)
    av6_df[!, "xpos"] = [x[1] - min_x for x in av6_df[:, "pos"]]
    av6_df[!, "ypos"] = [x[2] - min_y for x in av6_df[:, "pos"]]

    av7_df = filter(:id => id -> id == 8, model.df)
    av7_df[!, "xpos"] = [x[1] - min_x for x in av7_df[:, "pos"]]
    av7_df[!, "ypos"] = [x[2] - min_y for x in av7_df[:, "pos"]]

    av8_df = filter(:id => id -> id == 9, model.df)
    av8_df[!, "xpos"] = [x[1] - min_x for x in av8_df[:, "pos"]]
    av8_df[!, "ypos"] = [x[2] - min_y for x in av8_df[:, "pos"]]

    av9_df = filter(:id => id -> id == 10, model.df)
    av9_df[!, "xpos"] = [x[1] - min_x for x in av9_df[:, "pos"]]
    av9_df[!, "ypos"] = [x[2] - min_y for x in av9_df[:, "pos"]]

    av10_df = filter(:id => id -> id == 11, model.df)
    av10_df[!, "xpos"] = [x[1] - min_x for x in av10_df[:, "pos"]]
    av10_df[!, "ypos"] = [x[2] - min_y for x in av10_df[:, "pos"]]


    #POSITION ERROR
    #Puts the simulated agents x and y positions 
    sim_x = subj_df[:, "xpos"]
    sim_y = subj_df[:, "ypos"]


    #Puts the human x and y positions into variables
    hum_x = data["P"][model.subject, model.trial][:, 1]
    hum_y = data["P"][model.subject, model.trial][:, 2]

    mean_pos_error = mean(sqrt.((sim_x .- hum_x) .^ 2 .+ (sim_y .- hum_y) .^ 2))
    
    total_timepoints = nSteps


    #println("subject:", model.subject, "Trial:", model.trial)
    return DataFrame(
        subject=model.subject,
        trial=model.trial,
        density = Density,
        speed = O_Speed,
        mean_pos_error=mean_pos_error,
        kH = model.obstacleModel3_constants[:kᵩ],
        cH1 = model.obstacleModel3_constants[:c₁ᵩ],
        cH2 = model.obstacleModel3_constants[:c₂ᵩ]

    )

end
#end
    
# Main Execution
global all_data = DataFrame()

p = pmap(runmodel, 1:length(models); distributed=false, batch_size=1);

for d in 1:size(p)[1]
    append!(all_data, p[d])
    println("Progress: ", d, "/", size(p)[1])
end

filename = "./KV_dissExp1_gridSearch_1to50.csv"
CSV.write(filename, all_data)
  